# 1.7.1 제어의 역전(IoC)와 의존관계 주입

- IoC는 매우 느슨하게 정의돼서 폭넓게 사용되는 용어이다.

→ 따라서 스프링을 IoC 컨테이너라고만 해서는 스프링이 제공하는 기능의 특징을 명확하게 설명하지 못한다.

- 위와같은 이유로 `의존관계 주입(Dependency Injection)`이라는 좀 더 의도가 명확히 드러나는 이름을 사용하기 시작했다. 

# 1.7.2 런타임 의존관계 설정

먼저 의존관계란 무엇일까?

- `의존관계` : 두 개의 클래스 또는 모듈이 의존관계에 있다고 말할 때는 항상 `방향성`을 부여해주어야 한다.

- `UML 모델`  에서는 두 클래스의 의존관계를 다음과 같이 점선으로 된 화살표로 표현한다.

- 다음 그림은 A 가 B에 의존하고 있음을 나타낸다.

 ![캡처](https://github.com/yezanee/java-spring-study/assets/146803751/c384cf5d-9a5f-4d66-bd31-e03ec7a66653)

- 여기서 `의존한다`라는 의미는 클래스 B가 변하면 그것이 클래스 A에 영향을 미친다는 뜻이다. 즉, B의 기능이 추가되거나 변경되면 A도 그에 따라 수정되거나 추가되어야 한다.

- 대표적인 예로는 A에서 B에 정의된 메소드를 호출해서 사용하는 경우이다. (`사용에 대한 의존관계`)

- 다시 말하지만 의존관계에는 `방향성`이 있다. A는 B에 의존하고 있지만 B는 A의 변화에 영향을 받지 않는다.

### UserDao의 의존관계

지금까지 작업해왔던 UserDao의 예를 보자.

UserDao가 ConnecrionMaker에 의존하고 있는 형태이다.

아래 그림처럼 UserDao는 ConnectionMaker 인터페이스에 의존하고 있다.

따라서 ConnectionMaker 인터페이스가 변한다면 그 영향을 UserDao가 직접적으로 받게 된다. 

하지만 ConnectionMaker 인터페이스를 구현한 클래스, 즉 DConnecrionMaker 등이 다른것으로 바뀌거나 그 내부에서 사용하는 메소드에 변화가 생겨도 UserDao에는 영향을 주기 않는다.

이렇게 인터페이스에 대해서만 의존관계를 만들어두면 인터페이스 구현 클래스와의 관계는 느슨해지면서 변화에 영향을 덜 받는 상태가 된다. 이를 `결합도가 낮다`고 한다.

의존관계란 한 쪽의 변화가 다른 쪽에 영향을 주는 것이라고 했다. 따라서 인터페이스를 통해 의존관계를 제한해주면 그만큼 변경에 있어서 자유로워진다.

![image](https://github.com/yezanee/java-spring-study/assets/146803751/c65aea6e-4bf6-4141-9f39-db911ae89c10)


인터페이스를 통해 설계 시점에 느슨한 의존관계를 갖는 경우에는 UserDao의 오브젝트가 런타임 시에 사용할 오브젝트가 어떤 클래스로 만든 것인지 미리 알 수가 없다.

개발자나 운영자가 사전에 어떤 클래스의 오브젝트를 쓸지 미리 정해놓을 수는 있지만 그것이 UserDao나 ConnectionMaker등의 설계와 코드 속에서는 드러나지 않는다는 의미다.

이렇게 프로그램이 시작되고 UserDao 오브젝트가 만들어지고 나서 런타임 시에 의존관계를 맺는 대상, 즉 실제 사용대상인 오브젝트를 `의존 오브젝트` 라고 한다.

#### `의존관계 주입`: 구체적인 의존 오브젝트와 그것을 사용할 주체, 보통 클라이언트라고 부르는 오브젝트를 런타임 시에 연결해주는 작업

정리하면 의존관계 주입이란 다음고 같은 세 가지 조건을 충족하는 작업을 말한다.

- 코드에는 런타임 시점의 의존관계가 드러나지 않는다. 그러기 위해서는 인터페이스에만 의존하고 있어야 한다.

- 런타임 시점의 의존관계는 `컨테이너`나 `팩토리` 같은 `제3의 존재가 결정`한다.

- 의존관계는 사용할 오브젝트에 대한 레퍼런스를 외부에서 주입해줌으로써 만들어진다.

#### 의존관계 주입의 핵심은 설계 시점에는 알지 못했던 두 오브젝트의 관계를 맺도록 도와주는 제3의 존재가 있다는 것이다.

앞에서 만들었던 DaoFactory나 빈 팩토리, IoC 컨테이너 등이 모두 외부에서 오브젝트 사이의 런타임 관계를 맺어주는 제3의 존재라고 볼 수 있다.

### UserDao 의 의존관계 주입

```jsx
public UserDao() {
  connectionMaker = new DConnectionMaker();
}
```

UserDao에 적용된 의존관계 주입 기술을 다시 살펴보면

인터페이스를 사이에 두고 UserDao와 ConnectionMaker 구현 클래스 간에 의존관계를 느슨하게 만들긴 했지만, 런타임 시의 의존관계가 코드 속에 다 미리 결정되어있다는 문제점이 있다. (위 코드를 보면 설계 시점에서 DConnecrionMaker라는 구체적인 클래스의 존재를 알고있음)

그래서 IoC 방식을 써서 UserDao로부터 런타임 의존관계를 드러내는 코드를 제거하고, 제3의 존재에 런타임 의존관계 결정 권한을 위임해야됨. 

DaoFactory는 런타임 시점에 UserDao가 사용할 ConnectionMaker 타입의 오브젝트를 결정하고 이를 생성한 후에 UserDao의 생성자 파라미터로 주입해서 UserDao가 DConnectionMaker의 오브젝트와 런타임 의존관계를 맺게 해줌. (DI를 이용한 셈)

```jsx
public class DaoFactory {
  public UserDao userDao() {
    ConnectionMaker connectionMaker = new DConnectionMaker();
    UserDao userDao = new UserDao(connectionMaker);
    return userDao;
  }
}
```

DI 컨테이너는 UserDao를 만드는 시점에서 생성자의 파라미터로 이미 만들어진 DConnectionMaker의 오브젝트를 전달한다.

DI컨테이너는 자신이 결정한 의존관계를 맺어줄 클래스의 오브젝트를 만들고, 이 생성자의 파라미터로 오브젝트의 레퍼런스를 전달해준다.

다음 코드가 이 과정의 작업을 위해 필요한 전형적인 코드이다.

이렇게 생성자 파라미터를 통해 전달받은 런타임 의존관계를 갖는 오브젝트는 인스턴스변수에 저장해둔다.

```jsx
public class UseDao {
  private ConnectionMaker connectionMaker;

  public UserDao(ConnectionMaker connectionMaker) {
    this.connectionMaker = connectionMaker;
  }
...
}
```

이렇게 해서 두 개의 오브젝트 간에 런타임 의존관계가 만들어졌다.

UserDao 오브젝트는 이제 생성자를 통해 주입받은 DConectionMaker 오브젝트를 언제든 사용하면 된다.

이렇게 DI 컨테이너에 의해 런타임 시에 의존 오브젝트를 사용할 수 있도록 그 레퍼런스를 전달받는 과정이 마치 생성자를 통해 DI 컨테이너가 UserDao 에게 주입해주는것과 같다고 해서 이를 `의존관계 주입` 이라 부른다.

![image](https://github.com/yezanee/java-spring-study/assets/146803751/3f775aae-8d2d-42b2-aa6a-ceb43f5ee491)

# 1.7.3 의존관계 검색과 주입

- `의존관계 검색` : 의존관계를 맺는 방법 중 외부로부터의 주입이 아니라 스스로 검색을 이용하는 경우를 의미.

- 이 경우 자신이 필요로하는 의존 오브젝트를 능동적으로 찾음.(그러나 어떤 클래스의 오브젝트를 이용할지 결정하지는 x )

- 런타임 시 의존관계를 맺을 오브젝트를 결정하는 것과 오브젝트의 생성 작업은 외부 컨테이너에 IoC 로 맡기지만, 이를 가져올 때는 메소드나 생성자를 통한 주입 대신 `스스로 컨테이너에게 요청`하는 방법을 사용.

  
```jsx
public UserDao() {
 DaoFactory daoFactory - new Daofactory();
 thix.connectionMaker = daoFactory.connectionMaker();
}
```

이렇게 해도 UserDao 는 여전히 자신이 어떤 ConnectionMaker 오브젝트를 사용할 지 미리 알지 못함. 여전히 코드의 의존대상은 ConnectionMaker 인터페이스 뿐.

따라서 IoC 개념을 잘 따르고 있으며, 적용 방법은 외부로부터의 주입이 아니라 스스로 IoC 컨테이너인 DaoFactory 에게 요청하는 것.

# 1.7.4 의존관계 주입의 응용
