# 객체지향 언어

1️⃣ 코드의 재사용성이 높다

2️⃣ 코드의 관리가 용이

3️⃣ 신뢰성이 높은 프로그램을 가능케 함

- 클래스
    - `객체를 정의해놓은것` , `객체를 생성하는데 사용`
    - `객체` : 실제로 존재하는 것
    - ex) TV 설계도(클래스)는 TV(객체)를 정의한 것이며, TV를 만드는데 사용됨
    - 객체는 속성과 기능의 집합
    - `속성` : variable, `기능` : method
    
- 인스턴스
    - 클래스로부터 객체를 만드는 과정(인스턴스화)
    - 클래스로부터 만들어진 객체 = `인스턴스`
    - 인스턴스와 객체는 같은 의미지만, 객체가 좀 더 포괄적이고, 인스턴스가 좀 더 세부적인 느낌
    - 책상은 `객체`, 책상은 책상 클래스의 `인스턴스`
    
- 한 파일에 여러 클래스
    - 소스파일의 이름은 public class의 이름과 동일해야 함
    - 만약 public 없고 private만 존재 → 파일 이름 상관 없음(아무 class)
    - 한 파일 안에 여러 클래스는 가능하지만 public은 반드시 `하나만 존재`
    
- 객체의 생성과 사용
    
    ```jsx
    class_name variable_name; //클래스의 객체를 참조하기 위한 참조변수 선언
    variable_name = new class_name(); //클래스 객체 생성 후, 객체 주소를 참조변수에 저장
    
    TV k; //클래스 타입의 참조변수 k 선언
    k = new TV() //클래스 인스턴스 생성 후, 생성된 인스턴스의 주소를 k에 저장
    ```
    
    `인스턴스는 참조변수를 통해서만 다룰 수 있으며, 참조변수의 타입 = 인스턴스의 타입` 
    
- 같은 클래스로부터 생성되었더라도, 각 인스턴스의 variable은 다른 값을 유지할 수 있음
    
    ```jsx
    TV t1 = new TV();
    TV t2 = new TV();
    
    t1.channel = 7; //t1이 가리키고 있는 channel variable 값을 7로 변경
    //t2의 channel variable은 초기값인 0을 유지
    ```
    

- 객체 배열
    - TV tv1, tv2, tv3 → TV[] tvArr = new TV[3];
    - tvArr배열의 각 요소는 기본값인 null로 초기화, 이 객체 배열은 주소를 저장할 수 있음
    
    ```jsx
    Tv[] tvArr = new Tv[100];
    for(int i=0;i<tvArr.length;i++)
    {
    	tvArr[i] = new Tv();
    }
    ```
    

- 클래스
    - 사용자 정의 타입이 존재
    - 매번 수정하고 추가하기 번거로움 → 클래스를 사용
    - 제어자를 이용해서 변수의 값을 직접 변경하지 못하게 할 수 있음
    
    | 비객체지향적 | 객체지향적 |
    | --- | --- |
    | int hour1, hour2, hour3; | Time t1 = new Time();
    int minute1, minute2, minute3 | Time t2 = new Time();
    float second1, second2, second3 | Time t3 = new Time();
    int[] hour = new int[3]; | Time[] t = new Time[3];
    int[] minute = new int[3]; | t[0] = new Time();
    float second = new float[3]; | t[1] = new Time();
    | t[2] = new Time(); |
