## 7.1 상속

### 상속이란?

- 기존의 클래스를 재사용해서 새로운 클래스를 작성하는 것.
- 두 클래스를 조상과 자손으로 관계를 맺어주는 것.
- 자손은 조상의 모든 멤버를 상속받는다.(생성자, 초기화블럭 제외)
- 자손의 멤버개수는 조상보다 적을 수 없다.(같거나 많다.)

## 7.2 상속 예제

생략

## 7.3 클래스 간의 관계 - 포함관계

### 포함(composite)이란?

- 한 클래스의 멤버변수로 다른 클래스를 선언하는 것.
- 작은 단위의 클래스를 먼저 만들고, 이 들을 조합해서 하나의 커다란 클래스를 만든다.

## 7.4 클래스 간의 관계 결정하기

- **상속관계**: 원은 점이다. (`is-a)`
- **포함관계**: 원은 점을 가지고 있다.(`has-a`)

```jsx
class Point {
		int x;
		int y;
}

class Circle extends Point { //상속
		int r; // 반지름
}

class Circle { // 포함
		Point c = new Point(); // 원점
		int r; // 반지름
}
```

## 7.5 단일 상속

- Java는 단일상속만을 허용한다.(C++)은 다중상속 허용
- 비중이 높은 클래스 하나만 상속관계로, 나머지는 포함관계로 한다.

## 7.6 Object클래스 - 모든 클래스의 조상

- 조상이 없는 클래스는 자동적으로 Object클래스를 상속받게 된다.
- 상속계층도의 최상위에는 Object클래스가 위치한다.
- 모든 클래스는 Object클래스에 정의된 11개의 메서드를 상속받는다.

## 7.7 오버라이딩(overriding)

- **오버라이딩이란?**
    - 조상클래스로부터 상속받는 메서드의 내용을 상속받는 클래스에 맞게 변경하는 것

## 7.8 오버라이딩의 조건

1. 선언부가 같아야 한다.(이름, 매개변수, 리턴타입)
2. 접근제어자를 좁은 범위로 변경할 수 없다.
    - 조상의 메서드가 `protected`라면, 범위가 같거나 넓은 `protected`나 `public`으로만 변경할 수 있다.
3. 조상클래스의 메서드보다 많은 수의 예외를 선언할 수 없다.

## 오버로딩 vs 오버라이딩

- 오버로딩 - 기존에 없는 새로운 메서드를 정의하는 것(new)
- 오버라이딩 - 상속받은 메서드의 내용을 변경하는 것(change, modify)

## 7.10 참조변수 super

- `this` - 인스턴스 자신을 가리키는 참조변수, 인스턴스의 주소가 저장되어있음.
- `super` - `this`와 같음. 조상의 멤버와 자신의 멤버를 구별하는 데 사용.

## 7.11 super() - 조상의 생성자

- 자손의 생성자 첫 문장에서 조상의 생성자를 호출할 때 사용

## 7.11 패키지(package)

- 서로 관련된 클래스와 인터페이스의 묶음
- 클래스가 물리적으로 클래스파일인 것처럼, 패키지는 물리적으로 폴더이다. 패키지는 서브패키지를 가질 수 있으며, ‘.’ 으로 구분된다.
- 클래스의 실제 이름은 패키지명이 포함된 것이다.

## 7.12 패키지의 선언

- 패키지는 소스파일에 첫 번째 문장으로 단 한번 선언한다.
- 모든 클래스는 하나의 패키지에 속하며, 패키지가 선언되지 않은 클래스는 자동적으로 이름없는 패키지에 속하게 된다.

```jsx
package  패키지명;
```

## 7.14 클래스 패스(class path)

- 클래스패스는 클래스파일을 찾는 경로. 구분자는 ‘;’
- 클래스패스에 패키지가 포함된 폴더나 jar파일을 나열한다.
- 클래스패스가 없으면 자동적으로 현재 폴더가 포함되지만 클래스패스를 지정할 대는 현재 폴더(,)도 함께 추가해주어야 한다.

## 7.15 import문

- 사용할 클래스가 속한 패키지를 지정하는데 사용
- `import`문을 사용하면 클래스를 사용할 대 패키지명을 생략할 수 있다.
- `java.lang`패키지의 클래스는 `import`하지 않아도 사용할 수 있다.
- `import`문은 패키지문과 클래스선언의 사이에 선언한다.

```jsx
import 패키지명.클래스명;
import 패키지명.*;
```

## 7.16 static import문

- `static import`문을 사용하면 `static`멤버를 호출할 때 클래스 이름을 생략할 수 있다.

```jsx
Math.random(); -> random();
```

## 7.17 제어자

- 클래스, 변수 또는 메서드의 선언부에 함께 사용되어 부가적인 의미를 부여한다.

| 접근 제어자 | public, protected, (default), private |
| --- | --- |
| 그 외 | static, final, abstract, native, transient, synchronized, volatile, strictfp |

> 제어자들 간의 순서는 관계없지만 주로 접근 제어자를 제일 왼쪽에 놓는 경향이 있다.
> 

## 7.18 static - 클래스의, 공통적인

- `static`이 사용될 수 있는 곳 - 멤버변수, 메서드, 초기화 블럭
- **멤버변수**
    - 모든 인스턴스에 공통적으로 사용되는 클래스 변수가 된다.
    - 클래스 변수는 인스턴스를 생성하지 않고도 사용 가능하다.
    - 클래스가 메모리에 로드될 때 생성된다.
- **메서드**
    - 인스턴스를 생성하지 않고도 호출이 가능한 `static` 메서드가 된다.
    - `static`메서드 내에서는 인스턴스멤버들을 직접 사용할 수 없다.

## 7.19 final - 마지막의, 변경될 수 없는

- `final`이 사용될 수 있는 곳 - 클래스, 메서드, 멤버변수, 지역변수
- **클래스**
    - 변경될 수 없는 클래스
    - 확장될 수 없는 클래스
    - 다른 클래스의 조상이 될 수 없다.
- **메서드**
    - 변경될 수 없는 메서드
    - 오버라이딩을 통해 재정의 될 수 없다.
- **멤버변수, 지역변수**
    - 변경할 수 없는 상수

## 7.20 abstract - 추상의, 미완성의

- `abstact`가 사용될 수 있는 곳 - 클래스, 메서드
- **클래스**
    - 클래스 내에 추상 메서드가 선언되어 있음을 의미한다.
- **메서드**
    - 선언부만 작성하고 구현부는 작성하지 않은 추상 메서드임을 알린다.

## 7.21 접근 제어자(access modifier)

- 멤버 또는 클래스에 사용되어 외부로부터의 접근을 제한한다.

> 접근 제어자가 사용될 수 있는 곳 - 클래스, 멤버변수, 메서드, 생성자

`private`: 같은 클래스 내에서만 접근이 가능하다.
(`default`): 같은 패키지 내에서만 접근이 가능하다.
`protected`: 같은 패키지 내에서, 다른 패키지의 자손클래스에서 접근이 가능하다.
`public`: 접근 제한이 전혀 없다.
> 
- `public` > `protected` > (`default`) > `private`

## 7.22 캡슐화와 접근 제어자

- 접근 제어자를 사용하는 이유
    - 외부로부터 데이터를 보호하기 위해서
    - 외부에는 불필요한, 내부적으로만 사용되는, 부분을 감추기 위해서

---

## 코드 설명

```java
package hello.core.order;

public class Order {
    private Long memberId;
    private String itemName;
    private int itemPrice;
    private int discountPrice;

    public Order(Long memberId, String itemName, int itemPrice, int discountPrice) {
        this.memberId = memberId;
        this.itemName = itemName;
        this.itemPrice = itemPrice;
        this.discountPrice = discountPrice;
    }

    public int calculatePrice() {
        return itemPrice - discountPrice;
    }

    public Long getMemberId() {
        return memberId;
    }

    public String getItemName() {
        return itemName;
    }

    public int getItemPrice() {
        return itemPrice;
    }

    public int getDiscountPrice() {
        return discountPrice;
    }

    public void setMemberId(Long memberId) {
        this.memberId = memberId;
    }

    public void setItemName(String itemName) {
        this.itemName = itemName;
    }

    public void setItemPrice(int itemPrice) {
        this.itemPrice = itemPrice;
    }

    public void setDiscountPrice(int discountPrice) {
        this.discountPrice = discountPrice;
    }

    @Override
    public String toString() { // Object클래스의 메서드
        return "Order{" +
                "memberId=" + memberId +
                ", itemName='" + itemName + '\'' +
                ", itemPrice=" + itemPrice +
                ", discountPrice=" + discountPrice +
                '}';
    }
}
```
