# 객체지향 언어

1️⃣ 코드의 재사용성이 높다

2️⃣ 코드의 관리가 용이

3️⃣ 신뢰성이 높은 프로그램을 가능케 함

- 클래스
    - `객체를 정의해놓은것` , `객체를 생성하는데 사용`
    - `객체` : 실제로 존재하는 것
    - ex) TV 설계도(클래스)는 TV(객체)를 정의한 것이며, TV를 만드는데 사용됨
    - 객체는 속성과 기능의 집합
    - `속성` : variable, `기능` : method
    
- 인스턴스
    - 클래스로부터 객체를 만드는 과정(인스턴스화)
    - 클래스로부터 만들어진 객체 = `인스턴스`
    - 인스턴스와 객체는 같은 의미지만, 객체가 좀 더 포괄적이고, 인스턴스가 좀 더 세부적인 느낌
    - 책상은 `객체`, 책상은 책상 클래스의 `인스턴스`
    
- 한 파일에 여러 클래스
    - 소스파일의 이름은 public class의 이름과 동일해야 함
    - 만약 public 없고 private만 존재 → 파일 이름 상관 없음(아무 class)
    - 한 파일 안에 여러 클래스는 가능하지만 public은 반드시 `하나만 존재`
    
- 객체의 생성과 사용
    
    ```jsx
    class_name variable_name; //클래스의 객체를 참조하기 위한 참조변수 선언
    variable_name = new class_name(); //클래스 객체 생성 후, 객체 주소를 참조변수에 저장
    
    TV k; //클래스 타입의 참조변수 k 선언
    k = new TV() //클래스 인스턴스 생성 후, 생성된 인스턴스의 주소를 k에 저장
    ```
    
    `인스턴스는 참조변수를 통해서만 다룰 수 있으며, 참조변수의 타입 = 인스턴스의 타입` 
    
- 같은 클래스로부터 생성되었더라도, 각 인스턴스의 variable은 다른 값을 유지할 수 있음
    
    ```jsx
    TV t1 = new TV();
    TV t2 = new TV();
    
    t1.channel = 7; //t1이 가리키고 있는 channel variable 값을 7로 변경
    //t2의 channel variable은 초기값인 0을 유지
    ```
    

- 객체 배열
    - TV tv1, tv2, tv3 → TV[] tvArr = new TV[3];
    - tvArr배열의 각 요소는 기본값인 null로 초기화, 이 객체 배열은 주소를 저장할 수 있음
    
    ```jsx
    Tv[] tvArr = new Tv[100];
    for(int i=0;i<tvArr.length;i++)
    {
    	tvArr[i] = new Tv();
    }
    ```
    

- 클래스
    - 사용자 정의 타입이 존재
    - 매번 수정하고 추가하기 번거로움 → 클래스를 사용
    - 제어자를 이용해서 변수의 값을 직접 변경하지 못하게 할 수 있음
    
    | 비객체지향적 | 객체지향적 |
    | --- | --- |
    | int hour1, hour2, hour3; | Time t1 = new Time();
    int minute1, minute2, minute3 | Time t2 = new Time();
    float second1, second2, second3 | Time t3 = new Time();
    int[] hour = new int[3]; | Time[] t = new Time[3];
    int[] minute = new int[3]; | t[0] = new Time();
    float second = new float[3]; | t[1] = new Time();
    🍒 | t[2] = new Time(); |

- 선언위치에 따른 변수의 종류
    - `클래스 변수`, `인스턴스 변수`, `지역변수`
    - 우선 멤버 변수가 아니면 `지역변수` | 메서드 내에 선언되어 메서드 내에서만 사용 가능, 범위를 벗어나면 소멸되어 사용 불가능
    - 다음으로, static이 붙으면 `클래스 변수` | 모든 인스턴스가 공통된 변수를 공유 → 하나만 변경해도 모두가 변경됨, 인스턴스 생성없이 바로 사용 가능
    - 나머지는 `인스턴스 변수` | 클래스 영역에 선언됨, 인스턴스마다 고유한 상태를 유지하려면 이를 사용

- 예제

```jsx
class Ex6_3 {
	public static void main(String[] args) {
		System.out.println("Card.width = " + Card.width);
		System.out.println("Card.height = " + Card.height); //클래스 변수는 객체 생성 없이 바로 사용 가능

		Card c1 = new Card();
		c1.kind = "heart"; //인스턴스 변수의 값을 변경
		c1.number = 7;
		
		Card c2 = new Card();
		c2.kind = "Spade";
		c2.number = 4;

		System.out.println("c1은 " + c1.kind + ", " + c1.number);
		System.out.println("c2는 " + c2.kind + ", " + c2.number);
	}
}
class Card {
	String kind;
	static int width = 100;
	static int height = 250;
}
```
- 호출 스택
    - 메서드가 호출되면, 호출된 메서드를 위한 메모리가 할당됨
    - 이 메모리는 메서드가 작업을 수행하는 동안 `지역변수`와 연산의 `중간 결과를 저장`하는 데 사용됨
    - 메서드 작업 후 메모리는 비워짐
- 기본형 매개변수
    - `기본형` : 변수의 값을 읽기만 할 수 있음
        
        메서드의 매개변수 값이 변경됨 → 원본이 아닌 복사본이 변경된 것이라 원본에는 영향 X
        
    - `참조형` : 변수의 값을 읽고 변경할 수 있음
- 참조형 매개변수
    - 값이 저장된 주소를 매개변수로 넘겨주면, 값을 읽고 변경까지 가능함
    - 반환타입도 참조형이 될 수 있다
        
        → 그저 주소값이 반환될 뿐임 (기본형은 정수값)
        
- static과 인스턴스 메서드
    - 메서드도 변수와 동일하게 static이 붙어 있으면 클래스 메서드임
    - `클래스 메서드`는 객체 생성 없이 클래스 호출이 가능하다
    - 인스턴스 variable을 사용하지 않는다면 보통 static을 붙인다 (반드시는 아니지만 일반적임)
- static은 언제?
    
    1️⃣ 멤버 변수 중 모든 인스턴스에 공통으로 사용하는 것
    
    2️⃣ 클래스 변수는 인스턴스를 생성하지 않아도 사용할 수 있음
    
    3️⃣ 클래스 메서드는 인스턴스 변수를 사용할 수 없음
    
    → 인스턴스 변수는 인스턴스가 존재해야만 사용 가능한데, 클래스 메서드는 `인스턴스 없이도 호출 가능`하므로, 인스턴스가 존재하지 않을 수도 있어 사용을 금한다
    
    4️⃣ 메서드 내에서 인스턴스 변수를 사용하지 않는다면 static을 고려한다
    
    → 메서드 호출시간이 짧아지므로 성능이 향상된다
    
- 오버로딩
    - 메서드 이름이 같아야 함
    - 매개변수 개수, 타입이 달라야 함
    - 반환 타입은 상관 없음
    
    ⚠️ 매개변수의 순서만 바꿔도 오버로딩으로 간주함
    
- 생성자
    - 생성자의 이름은 클래스와 같아야 함
    - 생성자는 리턴값이 없음
    - new가 인스턴스를 생성하는 것이지, 생성자가 생성하는 것이 아님
    - 생성자는 초기화를 위한 특별한 메서드일 뿐
    - 기본 생성자는 `생성자가 단 하나도 존재하지 않을 때` 뿐임
    - 컴파일러는 생성자가 단 하나도 없을 시 기본 생성자를 추가하여 컴파일 함
    - 좀 더 객체지향적인 코드를 만들어낼 수 있음
    - this : 인스턴스 자신을 가리키는 참조변수, 인스턴스의 주소가 저장되어 있음
- `지역변수는 사용하기 전에 반드시 초기화를 하자`
- 멤버 변수의 초기화
    - 클래스 변수가 인스턴스 변수보다 먼저 초기화 됨(static이 먼저!)
    - 각 타입의 기본값으로 `자동 → 명시적 초기화 → 생성자` 순서로 초기화 됨
    - `명시적 초기화` : 가장 기본, 선언과 동시에 초기화 ex) int i = 0;
    - `초기화 블럭` : 아무것도 없이 **블럭**만 사용하여 코드 작성 ex) **{** System.out.println(”{ }”) **}**
```
# 6-1

```jsx
class Student {
	String name;
	int ban;
	int no;
	int kor;
	int eng;
	int math;
}
```

# 6-2

```jsx
String name;
int ban;
int no;
int kor;
int eng;
int math;
```

# 6-3

```jsx
String name;
int ban;
int no;
int kor;
int eng;
int math;

int getTotal() {
	return (kor + eng + math);
}

float getAverage() {
	float avg = getTotal()/3.0;
	return Math.round(avg*10)/10.0;
}
```

# 6-4

```jsx
return(Math.sqrt((x-x1)*(x-x1) + (y-y1)*(y-y1)));
```

```jsx
클래스 변수:
width, height

인스턴스 변수:
kind, num

지역변수:
k, n, card, args
```

# 6-6

```jsx
double getDistance(int x1, int y1) {
	return(Math.sqrt((x-x1)*(x-x1) + (y-y1)*(y-y1)));
}
```

```jsx
static int weapon = 6;
static int armor = 0;
static void weaponUp()
static void armorUp()

모든 병사의 공격력과 방어력은 같아야 하기 때문
static -> 하나의 요소를 바꾸면 모두의 요소가 변경된다
메서드 weaponUp()과 armorUp()은
각각 static변수 weapon과 armor를 가지고 작업을 하기 때문에 static을 붙이는 것이 맞다.
```

# 6-17

```jsx
public static int[] shuffle(int[] arr) {
	if(arr == null||arr.length==0)
		return arr;
	for(int i=0;i<arr.length;i++) {
		int j = (int)(Math.random()*arr.length)
		int tmp;
		arr[tmp] = arr[i];
		arr[i] = arr[j];
		arr[j] = arr[tmp];
	}
	return arr;
}
```

# 6-18

```jsx
public static boolean isNumber(String str) {
	if(str == null||str.length==0)
		return false;
	for(int i=0;i<str.length;i++)
	{
		if(str.charAt(i)<'0' || str.charAt(i)>'9')
			return false;
	}
	return true;
}
```

# 6-19

```jsx
1)
isPowerOn = !isPowerOn;

2)
if(volume<MAX_VOLUME)
	volume++;

3)
if(volume>MIN_VOLUME)
	volume--;

4)
channel++;
if(channel==MAX_CHANNEL)
	channel = MIN_CHANNEL;

5)
channel--;
if(channel==MIN_CHANNEL)
	channel = MAX_CHANNEL;
```

# 6-20

```jsx
public static int max(int[] arr)
{
	int max = arr[0];
	if(arr==null || arr.length==0)
		return -9999999;
	for(int i=0;i<arr.length;i++)
	{
		if(max<arr[i])
			max = arr[i];
	}
	return max;
}
```

# 6-21

```jsx
public static int abs(int value)
{
	if(value<0)
		value*=-1;
	return value;
}
```
