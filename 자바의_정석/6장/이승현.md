## 6.1 객체지향언어

1. 코드의 재사용성이 높다.
2. 코드의 관리가 용이하다.
3. 신뢰성이 높은 프로그래밍을 가능하게 한다.
- 재사용성, 유지보수, 중복된 코드의 제거, 이 세가지 관점에서 보면 쉽게 이해할 수 있다.
- 일단 프로그램을 기능적으로 완성한 다음 어떻게 하면 보다 객체지향적으로 코드를 개선할 수 있을지를 고민하여 점차 개선해 나가는 것이 좋다.

## 6.2 클래스와 객체

- **클래스의 정의**: 클래스란 객체를 정의 해 놓은 것
- **클래스의 용도**: 클래스는 객체를 생성하는데 사용
- **객체의 정의**: 실제로 존재하는 것. 사물 또는 개념
- **객체의 용도**: 객체의 속성과 기능에 따라 다름

> **참고**: 객체를 사용한다는 것은 객체가 가지고 있는 속성과 기능을 사용한다는 뜻이다.
> 

| 클래스 | 객체 |
| --- | --- |
| 제품 설계도 | 제품 |
| TV 설계도 | TV |
| 붕어빵기계 | 붕어빵 |

## 6.3 객체의 구성요소 - 속성과 기능

- 객체가 가지고 있는 **속성과 기능**을 그 객체의 **멤버**라 한다.
- Ex) TV

| 속성 | 크기, 길이, 높이, 색상, 볼륨, 채널 등 |
| --- | --- |
| 기능 | 켜기, 끄기, 볼륨 높이기, 볼륨 낮추기, 채널 변경하기 등 |
- 속성(property) → 멤버변수(variable)
- 기능(function) → 메서드(method)

- 채널 → int channel
- 채널 높이기 → channelUp() { … }

## 6.4 객체와 인스턴스

- 클래스로부터 객체를 만드는 과정을 **클래스의 인스턴스화**라고 한다.
- 어떤 클래스로부터 만들어진 객체를 그 클래스의 **인스턴스**라고 한다.
- 인스턴스는 객체와 같은 의미이지만, 객체는 모든 인스턴스를 대표하는 포괄적인 의미를 갖고 있다.
- 인스턴스는 어떤 클래스로부터 만들어진 것인지를 보다 강조하는 의미를 갖고 있다.
- “책상은 인스턴스다” → “책상은 객체다”
- “책상은 클래스의 객체이다” → “책상은 책상 클래스의 인스턴스다”
- 클래스 —`인스턴스화`—> 인스턴스(객체)

## 6.5 한 파일에 여러 클래스 작성하기

- 소스파일의 이름은 `public class`의 이름과 일치해야 한다.
- 만일 소스파일 내에 `public class`가 없다면, 소스파일 내의 어떤 클래스의 이름으로 해도 상관없다.
- 소스파일(`*.java`)와 달리 클래스파일(`*.class`)은 클래스마다 하나씩 만들어진다.

## 6.6 객체의 생성과 사용

```java
클래스명 변수명; // 클래스의 객체를 참조하기 위한 참조변수를 선언
변수명 = new 클래스명(); // 클래스의 객체를 생성 후, 객체의 주소를 참조변수에 저장

Tv t; // Tv클래스 타입의 참조변수 t를 선언
t = new Tv(); // Tv인스턴스를 생성한 후, 생성된 Tv인스턴스의 주소를 t에 저장
```

> 인스턴스는 참조변수를 통해서만 다룰 수 있으며,
참조변수의 타입은 인스턴스의 타입과 일치해야 한다.
> 

## 6.7 객체의 생성과 사용 예제

- 같은 클래스로부터 생성되었을 지라고 각 인스턴스의 속성(멤버변수)은 서로 다른 값을 유지할 수 있으며, 메서드의 내용은 모든 인스턴스에 대해 동일하다.

## 6.8 객체배열

- 많은 수의 객체를 다뤄야할 때, 배열로 다루면 편리할 것이다.
- `Tv tv1, tv2, tv3` → `Tv[] tvArr = new Tv[3]`

```java
Tv[] tvArr = new Tv[3]; // 참조변수 배열(객체배열)을 생성

// 객체를 생성해서 배열의 각 요소에 저장
tvArr[0] = new Tv();
tvArr[1] = new Tv();
tvArr[2] = new Tv();
```

## 6.9 클래스의 정의(1) - 데이터와 함수의 결합

- 객체지향이론의 관점
    - 클래스 = 객체를 생성하기 위한 틀이며, 속성과 기능
- 프로그래밍적 관점
    - 하나의 데이터를 저장하기 위해 변수를, 같은 종류의 데이터를 보다 효율적으로 다루기 위해서 배열이라는 개념을 도입
    - 후에는 구조체(structure)가 등장하여 자료형의 종류에 상관없이 서로 관계가 깊은 변수들을 하나로 묶어서 다룰 수 있도록 했다.
    - **서로 관련된 변수들을 정의하고 이들에 대한 작업을 수행하는 함수들을 함께 정의한 것이 바로 클래스이다.**

## 6.10 클래스의 정의(2) - 사용자 정의 타입

- 기본 자료형 외에 프로그래머가 서로 관련된 변수들을 묶어서 하나의 타입으로 새로 추가하는 것을 ‘사용자정의 타입(user - defined type)’이라고 한다.
- 자바와 같은 객체지향언어에서는 클래스가 곧 사용자 정의 타입이다.
- 기본형은 8개로 정해져 있지만 참조형의 개수는 정해져있지 않다.

```java
class Time {
	int hour;
	int minute;
	int second;
}

Time t1 = new Time();
Time[] t2 = new Time[3];
```

## 6.11 선언위치에 따른 변수의 종류

| 변수의 종류 | 선언 위치 | 생성 시기 |
| --- | --- | --- |
| 클래스 변수 | 클래스 영역 | 클래스가 메모리에 올라갈 때 |
| 인스턴스 변수 | 클래스 영역 | 인스턴스가 생성되었을 때 |
| 지역 변수 | 클래스 영역 이외의 영역
(메서드, 생성자, 초기화 블럭 내부) | 변수 선언문이 생성되었을 때 |
1. 인스턴스 변수
    - 값을 읽어 오거나 저장하려면 먼저 생성해야한다.
    - 인스턴스마다 별도의 저장공간을 가진다.
    - **인스턴스마다 고유한 상태를 유지해야하는 속성의 경우, 인스턴수 변수로 선언한다.**
2. 클래스 변수
    - 클래스 변수를 선언하는 방법은 인스턴스 변수 앞에 `static`을 붙이기만 하면 된다.
    - 인스턴스마다 독립적인 저장공간을 갖는 인스턴스 변수와 달리, 클래스 변수는 모든 인스턴스가 공통된 저장공간(변수)을 공유하게 된다.
    - **한 클래스의 모든 인스턴스들이 공통적인 값을 유지해야하는 속성의 경우, 클래스 변수로 선언해야 한다.**
    - 인스턴스 변수와 달리 인스턴스를 생성하지 않고 언제라도 바로 사용할 수 있다.
    - `클래스이름.클래스변수`와 같은 형식으로 사용한다.
3. 지역 변수
    - 메서드 내에 선언되어 메서드 내에서만 사용 가능하며, 메서드가 종료되면 소멸되어 사용할 수 없게 된다.

## 6.12 클래스 변수와 인스턴스 변수

- 카드 게임에 사용되는 카드를 클래스로 정의해보자.
- 카드의 속성: 무늬, 숫자, 폭, 높이
- 어떤 속성을 클래스 변수로 선언할 것이며, 또 어떤 속성들을 인스턴스 변수로 선언해야 할까?

```java
class card {
		String kind; // 무늬
		int number; // 숫자

		static int width = 100; // 폭
		static int height = 250; // 높이
}
```

- 각 카드는 자신만의 무늬와 숫자를 유지하고 있어야 하므로 이들을 인스턴스 변수로 선언하였다.
- 각 카드의 폭과 높이는 모든 인스턴스가 공통적으로 같은 값을 유지해야하므로 클래스 변수로 선언하였다.

> 인스턴스 변수는 인스턴스가 생성될 때 마다 생성되므로 인스턴스마다 각기 다른 값을 유지할 수 있지만, 클래스 변수는 모든 인스턴스가 하나의 저장공간을 공유하므로, 항상 공통된 값을 갖는다.
> 

## 6.13 클래스 변수와 인스턴스 변수 예제

생략

## 6.14 메서드란?

- 특정 작업을 수행하는 일련의 문장들을 하나로 묶은 것이다.
- 수학의 함수와 유사하다.
- 어떤 값을 입력하면 이 값으로 작업을 수행해서 결과를 반환한다.
- 메서드는 크게 두 부분, 선언부와 구현부로 이루어져 있다.
- 메서드를 저의한다는 것은 `선언부`와 `구현부`를 작성한다는 것을 뜻하며 다음과 같은 형식으로 메서드를 정의한다.

```java
반환타입 메서드이름(타입 변수명, 타입 변수명, ... ) {
		// 메서드 호출시 수행될 코드
}

int add(int a, int b) {
		int result = a + b;
		return result;
}
```

## 6.15 메서드의 선언부

- 메서드 선언부는 `메서드의 이름`과 `매개변수 선언`, 그리고 `반환타입`으로 구성되어 있다.

### 매개변수 선언

- 일반적인 변수선언과 달리 두 변수의 타입이 같아도 변수의 타입을 생략할 수 없다.

```java
int add(int x, int y) { ... } // OK
int add(int x, y) { ... } // 에러. 매개변수 y의 타입이 없다.
```

### 반환 타입

- 반환값이 없는 경우 반환타입으로 `void`를 적어야한다.

## 6.16 메서드의 구현부

- 메서드 선언부 다음에 오는 괄호 `{}`를 `메서드의 구현부`라고 한다.

### return

- `return 반환값` 문장은 반환값을 호출한 메서드로 전달하는데, 이 값의 타입은 반환타입과 **일치하거나 적어도 자동 형변환이 가능한 것**이어야 한다.
- 매개변수와 달리 단 하나의 값만 반환될 수 있다.

### 지역변수

- 메서드 내에 선언된 변수들은 그 메서드 내에서만 사용할 수 있다.
- 서로 다른 메서드라면 같은 이름의 변수를 선언해도 된다.

## 6.17 메서드의 호출

> `main`메서드는 프로그램 실행 시 OS에 의해 자동적으로 호출된다.
> 

```java
print99danAll(); // 메서드 호출
int result = add(3, 5); // 메서드를 호출하고 결과를 변수에 저장
```

- 메서드를 호출할 때 괄호() 안에 지정해준 값들을 ‘인수(argument)’ 또는 ‘인자’라고 한다.

## 6.18 메서드의 실행 흐름

생략

## 6.19 메서드의 실행 흐름 예제

생략

## 6.20 return문

- 현재 실행중인 메서드를 종료하고 호출한 메서드로 돌아간다.

## 6.21 반환값

- 반환값으로 변수가 오기도 하고 수식이 올 수도 있다.

## 6.22  호출 스택(call stack)

- 호출 스택은 메서드의 작업에 필요한 메모리 공간을 제공한다.
- 이 메모리는 메서드가 작업을 수행하는 동안 지역변수(매개변수 포함)들과 연산의 중간 결과 등을 저장하는데 사용된다.
- 메서드가 작업을 마치면 할당되었던 메모리 공간은 반환되어 비워진다.
- 호출스택의 특징
    - 메서드가 호출되면 수행에 필요한 만큼의 메모리를 스택에 할당받는다.
    - 메서드가 수행을 마치고나면 사용했던 메모리를 반환하고 스택에서 제거된다.
    - 호출스택의 제일 위에 있는 메서드가 현재 실행 중인 메서드이다.
    - 아래에 있는 메서드가 바로 위의 메서드를 호출한 메서드이다.

## 6.23 기본형 매개변수

- 기본형 매게변수: 변수의 값을 읽기만 할 수 있다.

## 6.24 참조형 매개변수

- 참조형 매게변수: 변수의 값을 읽고 변경할 수 있다.

## 6.25 참조형 반환타입

- 객체의 주소를 반환한다.

## 6.26 static 메서드와 인스턴스 메서드

- 메서드 앞에 static이 붙어 있으면 클래스 메서드이고 붙어 있지 않으면 인스턴스 메서드이다.
- 클래스 메서드는 객체를 생성하지 않고 `클래스이름.메서드이름(매개변수)`와 같은 식으로 호출이 가능하다.
- 인스턴스 메서드는 반드시 객체를 생성해야만 호출할 수 있다.
- 인스턴스 메서드는 인스턴스를 생성해야만 호출할 수 있는 것이다.
- 메서드 중에서 인스턴스와 관계없는(인스턴스 변수나 인스턴스 메서드를 사용하지 않는) 메서드를 일반적으로 클래스 메서드로 정의한다.

## 6.27 static 메서드와 인스턴스 메서드 예제

```java
class MyMath2 {
		// 인스턴스 변수
		long a, b;
		
		// 인스턴스 변수를 사용
		long add() { return a + b };
		
		// 매개변수만 사용(지역변수)
		static long add(long a, long b) { return a + b }
}

class Ex6_9 {
		public static void main(String args[]) {
				add(1, 2); // 3 
				MyMath2 myMath2 = new MyMath2(2, 3);
				myMath2.add(); // 5
		}
}
```

## 6.28 static을 어제 붙여야 할까요?

1. 클래스를 설계할 때, 멤버변수 중 모든 인스턴스에 공통으로 사용하는 것
2. 클래스 변수는 인스턴스를 생성하지 않아도 사용할 수 있다.
3. 클래스 메서드는 인스턴스 변수를 사용할 수 없다.
4. 메서드 내에서 인스턴스 변수를 사용하지 않는다면, static을 붙이는 것을 고려한다.
- 클래스의 멤버변수 중 모든 인스턴스에 공통된 값을 유지해야하는 것이 있는지 살펴보고 있으면, static을 붙여준다.
- 작성한 메서드 중에서 인스턴스 변수나 인스턴스 메서드를 사용하지 않는 메서드에 static을 붙일 것을 고려한다.

## 6.29 메서드 간의 호출과 참조

- 같은 클래스에 속한 멤버들 간에는 별도의 인스턴스를 생성하지 않고도 서로 참조 또는 호출이 가능하다.
- **단, 클래스멤버가 인스턴스 멤버를 참조 또는 호출하고자 하는 경우에는 인스턴스를 생성해야 한다.**

## 6.30 오버로딩(overloading)

- 한 클래스 내에 이미 사용하려는 이름과 같은 이름을 가진 메서드가 있어도 메개변수의 개수 또는 타입이 다르면, 같은 이름을 사용해서 메서드를 정의할 수 있다.
- 조건
    1. **메서드 이름이 같아야 한다.**
    2. **매개변수의 개수 또는 타입이 달라야 한다.**
    3. **반환 타입은 관계 없다.**

## 6.31 오버로딩(overloading) 예제

생략

## 6.32 생성자(constructor)

- 생성자는 인스턴스가 생성될 때 호출되는 ‘인스턴스 초기화 메서드’이다.

> 인스턴스 초기화란, 인스턴스변수들을 초기화하는 것을 뜻한다.
> 
- 생성자의 조건
    1. 생성자의 이름은 클래스의 이름과 같아야 한다.
    2. 생성자는 리턴 값이 없다.

```java
클래스이름(타입 변수명, 타입 변수명, ...) {
		// 인스턴스 생성 시 수행될 코드
		// 주로 인스턴스 변수의 초기화 코드를 적는다.
}
```

- 연산자 `new`가 인스턴스를 생성하는 것이지 생성자가 인스턴스를 생성하는 것이 아니다.

## 6.33기본 생성자

- 따로 정의하지 않아도 컴파일러가 제공하는 기본 생성자가 있다.

```java
클래스이름() {} // 기본 생성자
Point() {} // Point클래스의 기본 생성자
```

- 매개변수도 없고 아무런 내용도 없다.

> 클래스의 접근 제어자가  `public`인 경우에는 기본 생성자로 `public 클래스이름() {}` 이 추가된다.
> 
- 기본 생성자가 컴파일러에 의해서 추가되는 경우는 클래스에 정의된 생성자가 하나도 없을 때 뿐이다.

## 6.34 매개변수가 있는 생성자

- 인스턴스가 각기 다른 값으로 초기화되어야 하는 경우가 많기 때문에 매개변수를 사용한 초기화는 매우 유용하다.

```java
Car c = new Car();
c.color = "white";
c.gearType = "auto";
c.door = 4;
```

```java
Car c = new car("white", "auto", 4);
```

- 2번째 코드가 훨씬 유용하다.

## 6.35 매개변수가 있는 생성자 예제

생략

## 6.36 생성자에서 다른 생성자 호출하기 - this()

- 같은 클래스의 멤버들 간에 서로 호출할 수 있는 것처럼 생성자 간에도 서로 호출이 가능하다.
- 조건
    - 생성자의 이름으로 클래스이름 대신 `this`를 사용한다.
    - 한 생성자에서 다른 생성자를 호출할 때는 **반드시 첫 줄에서만 호출**이 가능하다.

```jsx
Car2() {
		door = 5;
		this("white", "auto", 4);
}
// 에러1: 생성자의 두 번째 줄에서 다른 생성자 호출
// 에러2: this(color, "auto", 4); 로 해야함
```

## 6.37 객체 자신을 가리키는 참조변수 - this

- 생성자의 매개변수로 선언된 지역변수와 인스턴수 변수의 이름이 같을 경우 사용한다.

```jsx
Car(String color, String gearType, int door) {
		this.color = color;
		this.gearType = gearType;
		this.door = door;
}
```

- `this`: 인스턴스 자신을 가리키는 참조변수, 인스턴스의 주소가 저장되어 있다. 모든 인스턴스메서드에 지역변수로 숨겨진 채로 존재한다.
- `this()`, `this(매개변수)`: 생성자. 같은 클래스의 다른 생성자를 호출할 때 사용한다.

## 6.38 변수의 초기화

- 멤버변수(클래스 변수와 인스턴스 변수)와 배열의 초기화는 선택이지만, 지역변수의 초기화는 필수이다.

```jsx
class InitTest {
		int x; // 인스턴스 변수
		int y = x; // 인스턴스 변수

		void method1() {
				int i; // 지역변수
				int j = i; // 에러. 지역변수를 초기화하지 않고 사용
		}
}
```

## 6.39 멤버변수의 초기화

- 지역변수와 달리 멤버변수는 각 타입의 기본값으로 자동 초기화 된다.
- 멤버변수의 초기화는 이 두 가지만 기억하면 된다.
    1. 클래스 변수(cv) 초기화 → 인스턴스 변수(iv) 초기화
    2. 자동 초기화 → 명시적 초기화(간단) → 초기화 블럭, 생성자(복잡)

### 명시적 초기화(explicit initialize)

- 변수를 선언과 동시에 초기화하는 것

```jsx
class Car {
		int door = 4; // 기본형(primitive type) 변수의 초기화
		Engine e = new Engine(); // 참조형(reference type) 변수의 초기화
		//...
}
```

### 초기화 블럭(initialize block)

- **클래스 초기화 블럭**: 클래스 변수의 복잡한 초기화에 사용된다.
- **인스턴스 초기화 블럭**: 인스턴스변수의 복잡한 초기화에 사용된다.
- 클래스 초기화 블럭은 처음 메모리가 로딩될 때 한번만 수행되지만, 인스턴스초기화 블럭은 인스턴스가 생성될 때 마다 수행된다.

## 6.40 멤버변수의 초기화 예제1

```jsx
static {
		System.out.println("static { }"); // 클래스 초기화 블럭
}

{
		System.out.println("{ }"); // 인스턴스 초기화 블럭
}
```

## 6.41 멤버변수의 초기화 예제2

생략
